from flask import Flask, request, jsonify
import threading
import cv2
import mediapipe as mp
import numpy as np
import base64
from flask_cors import CORS

app = Flask(__name__)
CORS(app, origins=["http://localhost:5014"])

counter = 0
stage = None
error = None
processing_active = False
current_frame = None  # New: to store frame for sending
stop_processing = False  # New: Flag to stop the background thread

mp_drawing = mp.solutions.drawing_utils
mp_pose = mp.solutions.pose


def get_four_points_squat(side, landmarks):
    if side == "left":
        foot_idx = [landmarks[mp_pose.PoseLandmark.LEFT_FOOT_INDEX.value].x,
                    landmarks[mp_pose.PoseLandmark.LEFT_FOOT_INDEX.value].y]
        hip = [landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].x,
               landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].y]
        knee = [landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].x,
                landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].y]
        ankle = [landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].x,
                 landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].y]
    else:
        foot_idx = [landmarks[mp_pose.PoseLandmark.RIGHT_FOOT_INDEX.value].x,
                    landmarks[mp_pose.PoseLandmark.RIGHT_FOOT_INDEX.value].y]
        hip = [landmarks[mp_pose.PoseLandmark.RIGHT_HIP.value].x,
               landmarks[mp_pose.PoseLandmark.RIGHT_HIP.value].y]
        knee = [landmarks[mp_pose.PoseLandmark.RIGHT_KNEE.value].x,
                landmarks[mp_pose.PoseLandmark.RIGHT_KNEE.value].y]
        ankle = [landmarks[mp_pose.PoseLandmark.RIGHT_ANKLE.value].x,
                 landmarks[mp_pose.PoseLandmark.RIGHT_ANKLE.value].y]
    return foot_idx, hip, knee, ankle

def calculate_angle(a, b, c):
    a = np.array(a)  # First
    b = np.array(b)  # Mid
    c = np.array(c)  # End

    radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])
    angle = np.abs(radians * 180.0 / np.pi)

    if angle > 180.0:
        angle = 360 - angle

    return angle

def calculate_dis(a, b):
    a = np.array(a)  # First
    b = np.array(b)  # Last
    return (b[0] - a[0])

def track_squat(foot_idx, hip, knee, ankle):
    global counter, stage, error
    angle = calculate_angle(hip, knee, ankle)
    dis = calculate_dis(knee, foot_idx)

    if angle >= 150:
        if stage == 'fin':
            counter += 1
        stage = 'start'
    elif angle < 100 and angle > 60:
        stage = 'fin'

    if dis >= 0.09 and angle < 100:
        error = "Knee too forward"
    else:
        error = None

def process_squat():
    global counter, stage, error, processing_active, current_frame, stop_processing
    cap = cv2.VideoCapture(r"C:\Users\Dell\Downloads\#rule-based (squat)\dataset\2.mp4")
    # cap = cv2.VideoCapture(0)

    with mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5) as pose:
        while processing_active and not stop_processing:
            ret, frame = cap.read()
            if not ret:
                break

            image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            results = pose.process(image_rgb)
            image = frame.copy()

            if results.pose_landmarks:
                landmarks = results.pose_landmarks.landmark
                visibility = lambda idx: landmarks[idx].visibility > 0.5

                if all([visibility(mp_pose.PoseLandmark.LEFT_HIP.value),
                        visibility(mp_pose.PoseLandmark.LEFT_KNEE.value),
                        visibility(mp_pose.PoseLandmark.LEFT_ANKLE.value),
                        visibility(mp_pose.PoseLandmark.LEFT_FOOT_INDEX.value)]):
                    foot_idx, hip, knee, ankle = get_four_points_squat("left", landmarks)
                    track_squat(foot_idx, hip, knee, ankle)
                elif all([visibility(mp_pose.PoseLandmark.RIGHT_HIP.value),
                          visibility(mp_pose.PoseLandmark.RIGHT_KNEE.value),
                          visibility(mp_pose.PoseLandmark.RIGHT_ANKLE.value),
                          visibility(mp_pose.PoseLandmark.RIGHT_FOOT_INDEX.value)]):
                    foot_idx, hip, knee, ankle = get_four_points_squat("right", landmarks)
                    track_squat(foot_idx, hip, knee, ankle)
                else:
                    error = "Not All Points Are showing"

            _, jpeg = cv2.imencode('.jpg', image)
            current_frame = base64.b64encode(jpeg).decode('utf-8')

    cap.release()
    processing_active = False  # ðŸ‘ˆ this line is the key fix

@app.route('/start', methods=['POST'])
def start_process():
    global processing_active, counter, stage, error, stop_processing
    data = request.get_json()
    if data and data.get("trigger") == "squat-rule-based":
        if not processing_active:
            processing_active = True
            stop_processing = False  # Reset stop flag when starting
            counter = 0
            stage = None
            error = None
            thread = threading.Thread(target=process_squat)
            thread.start()
        return jsonify({"message": "Processing started"}), 200
    elif data and data.get("trigger") == "stop":
        stop_processing = True  # Set stop flag to true
        return jsonify({"message": "Processing stopped"}), 200
    else:
        return jsonify({"error": "Invalid trigger"}), 400

@app.route('/status', methods=['GET'])
def get_status():
    global current_frame
    return jsonify({
        "counter": counter,
        "stage": stage,
        "error": error,
        "frame": current_frame
    })

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000)
